### Введение
Грамотно написанный класс должен ограничивать доступность своих членов и взаимодействовать с пользователем только через свйо интерфейс - API.
Необходимо ясно представлять себе то, как вы представляете работу с вашим классом других частей программы, а все, что не входит в интерфейс - скрывать, т.е инкапсулировать.

Как пишет Блох - главное правило заключается в том, чтобы сделать каждый класс или член максимально недоступным.

Почему?
Это просто понять, если представить себе, например, автомоболь. По сути, все, что является внутренностями машины - скрыто от вам, а API - это руль и педали.
Если бы все внутренности не были бы инкапсулированы - была бы большая вероятность поломки из-за случайности, 
например, ошибочного взаимодействия пользователя с инжектором(пользователь из интереса воткнул туда соломинку). 

Также и в программировании.

Если класс можно сделать доступным только в пакете - лучше сделать его таковым. 
В таком случае такой класс перестанет быть частью API, ведь он не будет `public`, он станет частью реализации пакета. 
При этом если вы когда-либо удалите или измените такой класс, вы не сломаете ничего у других, кто его использует(у клиентов), 
а если оставить его открытым, то необходимо будет поддерживать работоспособность такого класса, поддерживать совместимость и т.д.

#####Какие инструменты предоставляет Java для ограничения доступа?

В Java существует 4 модификатора доступа:
* `private` - мое и только мое
* `package` - доступ всем в пределах пакета
* `protected` - доступ у всех наследников и **доступ из любого класса в пакете, где объявлен класс с таким полем**!
* `public` - доступ отовсюду

Отсюда понятно, почему при переопределении метода у класса наследника, мы не можем изменить модификатор доступа на более узкий, например, 
если метод `public`, то в классе наследнике не получится сделать его `private`.
Это сделано для того, чтобы гарантировать, что объект класса наследника мы можем использовать везде, где можно было бы использовать объект супер класса.

##### Почему плохо делать поля public
Помимо того, что когда вы делаете поле `public` - вы включаете его в API класса, есть и еще одна негативная сторона.

Сделав поле класса открытым, мы не можем наложить *ограничения* на значения, 
которые поле может принимать, например, если сделать поле возраст(age) открытым, то мы не сможем проконтролировать, 
что в это поле кто-то запишет отрицательное значение, 
а также мы не можем среагировать на такое поведение клиента, например, сообщив, что возраст не может быть меньше 0.

```java
/**
 * Example of encapsulation
 */
class Person {
    private int age;
    private String name;

    public int getAge() {
        return age;
    }

    public String getName() {
        return name;
    }

    /**
     * We can't set age less zero.
     */
    public void setAge(int age) {
        if (age < 0) throw new IllegalArgumentException("Age can't be less then zero");
        this.age = age;
    }
}
```

Однако, не надо думать, что public никогда не используется при объявлении полей класса - 
`public` можно использовать с final-полями и неизменяемыми объектами. 

Необходимо помнить, что `final` не гарантирует нам, что вы не измените сам объект(если он модифицируемый). 
Т.е `final` гарантирует лишь то, что вы не измените ссылку на объект, но сам объект вы все также вольны менять.

`public` также часто используется для выставления констант наружу, делая их `public static final`.

**Никогда** не надо делать `public static final` массив, так как массив изменяемая структура данных, то все получат возможность менять значения в таком массиве. 
А это серьезная проблема.

Если вам все-таки хочется так сделать, то сделайте массив неизменяемым с помощью метода `Collections`.

#### Вывод
* Чем ниже уровень доступа - тем лучше
* Не делайте `public` полей, за исключением `public static final` констант. При этом такие константы не должны ссылаться на изменяемые объекты.
* Всегда старайтесь использовать все плюсы инкапсуляции - проверяйте значения, которые вы присваиваете полям и соответствующим образом реагируйте на ошибки.
* Если же вы не видите иного выхода, кроме как начать использовать `public` - продумайте API класса еще раз.
