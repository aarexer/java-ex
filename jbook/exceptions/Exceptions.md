###Введение
При написании приложения возникают некоторые нештатные, нестандартные ситуации.
Например:
* Оборвался коннект с БД
* Пользователь ввел некорректыне данные
* Не можем закрыть файл
* Не хватает памяти
* и т.д

Что же с ними делать?
Такие ситуации можно либо игнорировать, либо как-то реагировать.

Мы можем возвращать некий код ошибки, а после уже расшифровывать(интерпритировать) его. Но такой способ неудобен, так как слишком немногословен, требует помнить коды-ошибок(либо постоянно сверятся с документацией),  а также не позволяет удобно обрабатывать такие ситуации. Поэтому в Java используется механизм Exceptions.

В Java механизм Exception - построен на классах, которые хранят в себе некие данные о нестандартной ситуации - причину, сообщение и т.д

Рассмотрим механизм исключений в Java подробнее.

#### Иерархия исключений

Ниже мы видим иерархию исключений, корень - `java.lang.Throwable` и два класса - `java.lang.Exception` и `java.lang.Error`, это два главных класса.
`java.lang.Exception` - это super class для `java.lang.RuntimeException`.

![](../../images/exceptions.png)

Понятно, что раз мы работаем с классами, то мы можем наследоваться от этих классов и создавать собственные исключения.
Надо понимать, что Exceptions - это тоже классы, т.е мы туда можем положить свою логику, методы и переменные, если надо. Однако кидать исключения - довольно дорогая операция, поэтому не надо просто так разбрасываться ими.

В Java исключения делятся на два типа. Это так называемые checked и unchecked - проверяемые и непроверяемые исключения. Ниже рассмотрим подробнее их.
Как мы видим по схеме `java.lang.Throwable` и `java.lang.Exception` - это checked exceptions, `java.lang.RuntimeException` и `java.lang.Error` - это unchecked.

Runtime Exceptions - это исключения времени выполнения
Checked exceptions проверяются компилятором в Сompile Time. И их мы обязаны обработать. В то время как RE(Runtime Exceptions) мы не обязаны явно перехватывать и обрабатывать, ну на то они и runtime:)

Мы также можем перехватывать исключения. И перехватывать мы можем все виды исключений.

Но тогда зачем нам столько видов исключений?

### Exceptions

* java.lang.Exception
Это ситуации, которые нам не подконтрольны, т.е не смогли закрыть файл, не смогли дессериализовать класс - мы ничего не можем сделать, но можем отреагировать.
Опять же мы обязаны такие исключения обрабатывать. Либо прокидывать вверх с помощью throws, в сигнатуру метода. Метод может декларировать сколько угодно исключений.

* java.lang.RuntimeException
А вот тут уже - это наши ошибки, ошибки разработчика скорее. Т.е обращаемся к null, делим на ноль где-то и прочее.
Мы можем эти ошибки перехватывать, а можем пропускать. Ловить такие ошибки постоянно - не совсем правильно наверное, так как мы можем так и не понять причину ошибок и падений.

* java.lang.Error
Критические ошибки, после которых мы не можем или с трудом можем продолжать работу.
Как и все остальные - мы можем такие ошибки ловить, но зачем? Ловить их можно только в случае, если мы можем или знаем как нам поступить в таких ситуациях.

Кидать мы можем тоже любые исключения.

### Error vs Exception
Error - это более серьезная ситуация, нежели Exception. Т.е если происходит что-то такое, что мы либо не можем исправить, либо это крайне сложно починить, например, у нас закончилась память или мы вызываем несуществующий метод - это вот `Error`. Т.е непросто исключительная ситуация - а прямо рядом с паникой:)
Но если мы не можем закрыть файл, мы делаем какой-нибудь запрос, не можем строку к число преобразовать - это ситуации, после которых мы **можем** продолжить работать, мы можем перехватить это, обработать(например - попросить пользователя ввести еще раз число) - это `java.lang.Exception`.

Т.е разница - в *логическом разделении*.

### How to handle
Ловить и обрабатывать ошибки - try/catch/finally.

Сразу надо сказать, что try-catch блок - **не транзакционный**, т.е мы создаем объекты в try, работаем и тут хоп! - ошибка, так вот объекты так и останутся в памяти, если мы их не почистим в finally или catch блоке.

Также, мы не можем работать с объектами из try блока в других блоках - почему? Потому что компилятор не может нам гарантировать, что эти объекты создались, а вдруг у вас там кинулся Exception? Тогда после исключения строчки кода не выполняются и объекты мы не создали, а значит и работать с ними не можем.

Еще один момент, это так называемый re-throw.
Это когда вы перехватываете exception в catch-block, формируете там еще один и выбрасываете уже его, возможно(почти обязательно) вкладывая предыдущий в этот.
Т.е:
```java
try {
Reader readerConf = ....
readerConf.readConfig();
} catch(IOException ex) {
//logging error
throw new ComponentException(ex)
}
```
Что мы сделали?Мы перехватили ошибку чтения, обернули ее в новую ошибку и выкинули наверх. Для чего это нужно? Это полезно для гибкой обработки ошибок, т.е неважно что стало с нашим конфигом(нет файла, нет какой-то строки) - мы формируем ошибку, что мы не можем работать с этим компонентом программы.

Расположение catch blocks - важно.
Пусть у нас метод бросает IOException и Exception, мы пишем что-то типа такого:
```java
try {
method();
} catch (Exception e) {//do some logic 1}
catch (IOException e) {//do some logic 2}
```

И видим, что IOException обработка недостижима, мы более широкий фильтр "отлова" установили выше.

Это похоже на то, как мы используем сито. Есть более широкие, есть уже. Так вот, если установить выше всех узкое сито - до низу почти ничего не дойдет, ведь мы все перехватим выше. Принцип ясен.

Отсюда понятно, что если нам надо перехватить прямо вот **все**, то надо ловить Throwable:
```java
try {
method();
} catch (Throwable t) {//do some logic 1}
```

Отметим, что в таком подходе мы ловим и RE, и Error!

Ловим RE:
```java
try {
   String numberAsString = "one";
   Double res = Double.valueOf(numberAsString);
    } catch (RuntimeException re) {
            System.out.println("Error while convert string to double!");
    }
```

Ловим Error:

```java
        try {
            throw new Error();
        } catch (RuntimeException re) {
            System.out.println("RE");
        } catch (Error error) {
            System.out.println("ERROR");
        }
    }
```
В целом - что мы ставим в catch - все, что ниже по иерархии мы и ловим.
Все вроде бы ясно и понятно. Теперь вот еще что.

Полезно иногда иметь свою иерархию Exceptions. Например, у нас есть method2() и он кидает целых 3 разных Exception-а. Имея свою иерархию мы просто пишем 3 catch block-а на каждое исключение и обрабатываем как нам надо. Без этого у нас был бы только один catch block с перехватом Exception, где мы уже будем понимать что мы вообще перехватили и как это обрабатывать.

Идем дальше.

А что если наше исключение прерывает поток(interrupt thread) - все просто используем `Thread.UncaughtExceptionHandler`.

И еще раз! Аккуратнее с обработкой исключений.
```java
public static void main(String[] args){
        try {
            try {
                throw new Exception("0");
            } finally {
                if (true) {
                    throw new IOException("1");
                }
                System.err.println("2");
            }
        } catch (IOException ex) {
            System.err.println(ex.getMessage());
        } catch (Exception ex) {
            System.err.println("3");
            System.err.println(ex.getMessage());
        }
    }
```

Видим на выходе "1"!


Однако сазу надо сказать, что хоть вы и *можете* наследоваться от Throwable, однако это крайне не рекомендуется.

####Вывод
* Используем обрабатываемые исключения в случае, когда мы понимаем, что тут может быть ошибка.
* Не обрабатываемое исключение - если это наша ошибка.
* Полезно иметь свою иерархию исключений.
* Используйте finally, если работаете с ресурсами и try-with-resources
* finally блок отрабатывает всегда.
* Кидаем исключения с помощью `throw`
* Поднять исключение выше -  `throws`
* Все проверяемые исключения обязаны быть отловлены!
* try-catch block **не транзакционный** - все объекты, которые создали в try *ДО* исключения остаются в памяти.


//todo
Переопределяющий метод не должен бросать новое или более широкое исключение, однако он может ВООБЩЕ не бросать исключение!
