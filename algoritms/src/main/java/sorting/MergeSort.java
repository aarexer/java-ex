package sorting; /**
 * sorting.MergeSort, сортировка слиянием.
 */

/**
 * @author rexer
 */
class MergeSort
{
    /**
     *
     * @param left  Первый массив
     * @param right Второй массив
     * @return      Соединенные в правильном порядке два массива
     */
    public static int[] merge(int [] left, int [] right)
    {
        //Понятно, что длина результирующего массива - это
        //длина первого плюс длина второго.
        int [] res = new int[left.length + right.length];
        //ИНдексы:
        //aindex - это индекс привязанный к первому массиву
        //bindex - ко второму
        //index - это результирующий,для массива res
        int aindex = 0;
        int bindex = 0;
        int index = 0;
        //Пока один из массивов не закончится, мы сравниваем элементы друг с другом
        //Сравниваем и записываем в res
        while (aindex < left.length && bindex < right.length)
        {
            if (left[aindex] < right[bindex])
            {
                res[index] = left[aindex++];
                index++;
            }
            else
            {
                res[index] = right[bindex++];
                index++;
            }
        }
        //Как только мы вышли из верхнего цикла, то мы должны записать оставшиеся элементы одного из массивов
        //В результат. При этом заметим, что одно из условий в первом или втором цикле снизу заведомо ложно, т.к
        //один из массивов уже закончился.
        //Т.е мы просто дозаписываем оставшиеся элементы в конец, так как массивы отсортированные мы получили, то
        //очевидно, что то, что осталось - наибольшие элементы, при этом еще и упорядоченные.
        while (aindex < left.length)
        {
            res[index] = left[aindex++];
            index++;
        }

        while (bindex < right.length)
        {
            res[index] = right[bindex++];
            index++;
        }
        //Вернем результат.
        return res;
    }

    /**
     *
     * @param array массив элементов, который надо сортировать
     * @param from  индекс, начиная с которого сортируем
     * @param len   длина массива
     * @return  возвращает отсортированный массив
     */
    public static int[] mergesort(int [] array, int from, int len)
    {
        //Если встречам массив нулевого размера, то возвращаем пустой массив.
        if (len == 0)
            return new int[0];
            //Если массив содержит один элемент - его и возвращаем.
        else if (len == 1)
            return new int[]{array[from]};
            //Если в массиве два элемента, то:
        else if (len == 2)
        {
            //а) Если первый больше второго, то возвращаем массив, где наши элементы поменены местами.
            if (array[from] > array[from + 1])
            {
                return new int[] {array[from + 1], array[from]};
            }
            //б) Если нет, то возвращаем массив, где порядок элементов сохранен.
            else
            {
                return new int[] {array[from], array[from + 1]};
            }

        }
        //Если же размер массива больше двух элементов, то:
        //Разбиваем массив на две части. Первая часть - left, вторая - right.
        //Запускаем рекурсивно себя,передавая все тот же массив, однако индекс начала сортировки и длины для каждого
        //из двух массивов теперь разгный.
        //В первом мы сортируем от того же элемента, что и в первый раз, но до len/2
        //Во втором же от половины + индекс начала, длиной len - len/2.
        //Такая длина указан из-за того, что длина массива не всегда четная.
        else
        {
            int[] left = mergesort(array, from, (len / 2));
            int[] right = mergesort(array, from + (len / 2), len - (len / 2));

            //Теперь надо слить два отсортированных массива в один, но не просто слить, а правильно смерджить.
            //Т.е смерджить тоже надо по порядку, для этого вызываем функцию с сигнатурой merge(int[] a, int [] b)
            return merge(left, right);
        }
    }
}